#!/bin/zsh

# Test script for zsh configuration
# Validates that all tools and environment are working correctly after zshrc changes
# Reads package configuration from packages.json

# Color codes for beautiful output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# Unicode symbols
CHECK="✓"
CROSS="✗"
ARROW="→"
STAR="★"
INFO="ℹ"
WARN="⚠"

# Test counters
PASSED=0
FAILED=0
WARNINGS=0

# Get dotfiles directory
DOTFILES_DIR="${HOME}/dotfiles"
if [ ! -d "$DOTFILES_DIR" ]; then
    DOTFILES_DIR="${HOME}/.dotfiles"
fi

PACKAGES_JSON="$DOTFILES_DIR/packages.json"

# Print section header
print_header() {
    echo ""
    echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${BOLD}${CYAN}${STAR} $1${RESET}"
    echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
}

# Print test result
print_test() {
    local name="$1"
    local test_status="$2"
    local details="$3"

    if [[ "$test_status" == "pass" ]]; then
        echo -e "${GREEN}  ${CHECK} ${name}${RESET}"
        [[ -n "$details" ]] && echo -e "    ${CYAN}${ARROW} ${details}${RESET}"
        ((PASSED++))
    elif [[ "$test_status" == "fail" ]]; then
        echo -e "${RED}  ${CROSS} ${name}${RESET}"
        [[ -n "$details" ]] && echo -e "    ${RED}${ARROW} ${details}${RESET}"
        ((FAILED++))
    elif [[ "$test_status" == "warn" ]]; then
        echo -e "${YELLOW}  ${WARN} ${name}${RESET}"
        [[ -n "$details" ]] && echo -e "    ${YELLOW}${ARROW} ${details}${RESET}"
        ((WARNINGS++))
    else
        echo -e "    ${INFO} ${name}: ${details}"
    fi
}

# Test a command and version
test_tool() {
    local tool_name="$1"
    local command="$2"
    local version_cmd="$3"
    local optional="${4:-false}"

    if command -v "$command" >/dev/null 2>&1; then
        local version
        version=$(eval "$version_cmd" 2>&1 | head -n 1)
        print_test "$tool_name" "pass" "$version"
        return 0
    else
        if [[ "$optional" == "true" ]]; then
            print_test "$tool_name" "warn" "Not installed (optional)"
        else
            print_test "$tool_name" "fail" "Command not found"
        fi
        return 1
    fi
}

# Test environment variable
test_env_var() {
    local var_name="$1"
    local var_value="${(P)var_name}"

    if [[ -n "$var_value" ]]; then
        print_test "$var_name" "pass" "$var_value"
        return 0
    else
        print_test "$var_name" "warn" "Not set"
        return 1
    fi
}

# Start tests
clear
echo -e "${BOLD}${MAGENTA}"
echo "╔══════════════════════════════════════════════════════════════╗"
echo "║                                                              ║"
echo "║           ZSH Configuration Validation Suite                 ║"
echo "║                                                              ║"
echo "╚══════════════════════════════════════════════════════════════╝"
echo -e "${RESET}"
echo -e "${CYAN}Testing dotfiles configuration and tool availability...${RESET}"
echo -e "${CYAN}Date: $(date '+%Y-%m-%d %H:%M:%S')${RESET}"

# ============================================================================
# SHELL ENVIRONMENT
# ============================================================================
print_header "Shell Environment"

echo -e "${CYAN}  Shell: ${RESET}$SHELL"
echo -e "${CYAN}  ZSH Version: ${RESET}$ZSH_VERSION"
echo -e "${CYAN}  Terminal: ${RESET}${TERM_PROGRAM:-$TERM}"

if [[ -f ~/.zshrc ]]; then
    local zshrc_path
    zshrc_path=$(readlink ~/.zshrc 2>/dev/null || echo ~/.zshrc)
    print_test "ZSHRC Location" "pass" "$zshrc_path"
else
    print_test "ZSHRC Location" "fail" "~/.zshrc not found"
fi

# ============================================================================
# CORE ENVIRONMENT VARIABLES
# ============================================================================
print_header "Environment Variables"

test_env_var "HOME"
test_env_var "PATH"
test_env_var "NVM_DIR"
test_env_var "SDKMAN_DIR"
test_env_var "JAVA_HOME"

# ============================================================================
# PACKAGES FROM packages.json
# ============================================================================

# Check if packages.json exists and is readable
if [[ ! -f "$PACKAGES_JSON" ]]; then
    print_header "Package Configuration"
    print_test "packages.json" "warn" "Not found at $PACKAGES_JSON, using manual tests"
    USE_MANUAL_TESTS=true
else
    # Check if jq is available for JSON parsing
    if ! command -v jq >/dev/null 2>&1; then
        print_header "Package Configuration"
        print_test "jq (JSON parser)" "warn" "Not installed, using manual tests"
        USE_MANUAL_TESTS=true
    else
        USE_MANUAL_TESTS=false

        # Test packages from packages.json
        print_header "Core Packages (from packages.json)"

        # Get all enabled packages from core category
        local core_packages
        core_packages=$(jq -r '.categories.core.packages | to_entries[] | select(.value.enabled == true) | .key' "$PACKAGES_JSON" 2>/dev/null)

        if [[ -n "$core_packages" ]]; then
            while IFS= read -r package; do
                local required
                required=$(jq -r ".categories.core.packages.\"$package\".required" "$PACKAGES_JSON" 2>/dev/null)

                # Map package names to commands
                local cmd="$package"
                case "$package" in
                    "starship") cmd="starship"; version_cmd="starship --version" ;;
                    "git-delta") cmd="delta"; version_cmd="delta --version" ;;
                    "git-flow-avh") cmd="git-flow"; version_cmd="git flow version" ;;
                    "lazygit") cmd="lazygit"; version_cmd="lazygit --version" ;;
                    "ripgrep") cmd="rg"; version_cmd="rg --version | head -1" ;;
                    *) version_cmd="$cmd --version" ;;
                esac

                local optional="false"
                [[ "$required" == "false" ]] && optional="true"

                test_tool "$package" "$cmd" "$version_cmd" "$optional"
            done <<< "$core_packages"
        fi

        # Test security packages
        print_header "Security Tools (from packages.json)"

        local security_packages
        security_packages=$(jq -r '.categories.security.packages | to_entries[] | select(.value.enabled == true) | .key' "$PACKAGES_JSON" 2>/dev/null)

        if [[ -n "$security_packages" ]]; then
            while IFS= read -r package; do
                local required
                required=$(jq -r ".categories.security.packages.\"$package\".required" "$PACKAGES_JSON" 2>/dev/null)
                local optional="false"
                [[ "$required" == "false" ]] && optional="true"

                test_tool "$package" "$package" "$package --version" "$optional"
            done <<< "$security_packages"
        fi

        # Check age keys if sops is enabled
        if [[ -f "$HOME/.config/sops/age/keys.txt" ]]; then
            print_test "Age Keys" "pass" "Found at $HOME/.config/sops/age/keys.txt"
        else
            print_test "Age Keys" "warn" "Not found (required for encrypted secrets)"
        fi

        # Test development packages
        local dev_enabled
        dev_enabled=$(jq -r '.categories.development.enabled' "$PACKAGES_JSON" 2>/dev/null)

        if [[ "$dev_enabled" == "true" ]]; then
            print_header "Development Tools (from packages.json)"

            local dev_packages
            dev_packages=$(jq -r '.categories.development.packages | to_entries[] | select(.value.enabled == true) | .key' "$PACKAGES_JSON" 2>/dev/null)

            if [[ -n "$dev_packages" ]]; then
                while IFS= read -r package; do
                    case "$package" in
                        "nvm")
                            if command -v nvm >/dev/null 2>&1 || type nvm >/dev/null 2>&1; then
                                local nvm_version
                                nvm_version=$(nvm --version 2>&1)
                                print_test "NVM" "pass" "v$nvm_version"
                            else
                                print_test "NVM" "warn" "Not loaded"
                            fi
                            ;;
                        "pyenv")
                            test_tool "pyenv" "pyenv" "pyenv --version" "true"
                            ;;
                        "rbenv")
                            test_tool "rbenv" "rbenv" "rbenv --version" "true"
                            ;;
                    esac
                done <<< "$dev_packages"
            fi
        fi

        # Test special installations
        print_header "Special Installations (from packages.json)"

        local sdkman_enabled
        sdkman_enabled=$(jq -r '.special_installations.sdkman.enabled' "$PACKAGES_JSON" 2>/dev/null)

        if [[ "$sdkman_enabled" == "true" ]]; then
            if [[ -d "$HOME/.sdkman" ]]; then
                print_test "SDKMAN" "pass" "Installed at $HOME/.sdkman"
            else
                print_test "SDKMAN" "warn" "Not found"
            fi
        fi

        local zinit_enabled
        zinit_enabled=$(jq -r '.special_installations.zinit.enabled' "$PACKAGES_JSON" 2>/dev/null)

        if [[ "$zinit_enabled" == "true" ]]; then
            if [[ -d "${HOME}/.local/share/zinit/zinit.git" ]]; then
                print_test "Zinit Plugin Manager" "pass" "Installed"
            else
                print_test "Zinit Plugin Manager" "warn" "Not found"
            fi
        fi
    fi
fi

# ============================================================================
# PROGRAMMING LANGUAGES & RUNTIMES (Manual checks for installed tools)
# ============================================================================
print_header "Programming Languages & Runtimes"

# Java
test_tool "Java" "java" "java -version 2>&1 | head -n 1"

# Node.js (via NVM)
test_tool "Node.js" "node" "node --version"

# NPM
test_tool "NPM" "npm" "npm --version"

# Ballerina
test_tool "Ballerina" "bal" "bal version 2>&1 | head -n 1"

# Python (optional)
test_tool "Python" "python3" "python3 --version" "true"

# Ruby (optional)
test_tool "Ruby" "ruby" "ruby --version" "true"

# Go (optional)
test_tool "Go" "go" "go version" "true"

# ============================================================================
# DEVELOPMENT TOOLS
# ============================================================================
print_header "Development Tools"

# Claude Code (critical for this workflow!)
test_tool "Claude Code" "claude" "claude --version"

# Git
test_tool "Git" "git" "git --version"

# Docker (optional)
test_tool "Docker" "docker" "docker --version" "true"

# Gradle (check if wrapper exists in current dir, otherwise check system)
if [[ -f ./gradlew ]]; then
    print_test "Gradle Wrapper" "pass" "Found in current directory"
elif command -v gradle >/dev/null 2>&1; then
    test_tool "Gradle" "gradle" "gradle --version | head -n 3 | tail -n 1" "true"
else
    print_test "Gradle" "warn" "Not in current directory or PATH (optional)"
fi

# Maven (optional)
if command -v mvn >/dev/null 2>&1; then
    test_tool "Maven" "mvn" "mvn --version | head -n 1" "true"
fi

# ============================================================================
# SHELL PLUGINS & FEATURES
# ============================================================================
print_header "Shell Plugins & Features"

# Note: Functions and aliases are loaded in the parent shell but not visible in test subshell
echo -e "${CYAN}  Custom Functions & Aliases: ${RESET}Loaded in parent shell (not testable in subshell)"

# Check for plugin manager installations instead
if [[ -d "${HOME}/.local/share/zinit/zinit.git" ]]; then
    print_test "Zinit Plugin Manager" "pass" "Installed"
else
    print_test "Zinit Plugin Manager" "warn" "Not found"
fi

# Test Starship prompt configuration
if command -v starship >/dev/null 2>&1; then
    local starship_config="$HOME/.config/starship.toml"
    if [[ -f "$starship_config" ]] || [[ -L "$starship_config" ]]; then
        # Test if starship can be initialized
        if starship init zsh >/dev/null 2>&1; then
            print_test "Starship Config" "pass" "starship.toml loads correctly"
        else
            print_test "Starship Config" "fail" "Initialization errors in starship.toml"
        fi

        # Show config location
        print_test "Starship Location" "pass" "Config at $starship_config"
    else
        print_test "Starship Config" "fail" "starship.toml not found at $starship_config"
    fi
else
    print_test "Starship" "warn" "Not installed"
fi

# ============================================================================
# ENVIRONMENT FILES
# ============================================================================
print_header "Configuration Files"

if [[ -f "$HOME/.env" ]]; then
    print_test "Environment File" "pass" "Found at $HOME/.env"
else
    print_test "Environment File" "warn" "Not found at $HOME/.env"
fi

if [[ -f "$PACKAGES_JSON" ]]; then
    print_test "packages.json" "pass" "Found at $PACKAGES_JSON"
else
    print_test "packages.json" "warn" "Not found"
fi

# ============================================================================
# PATH VALIDATION
# ============================================================================
print_header "PATH Validation"

# Check for common important paths
local important_paths=(
    "/opt/homebrew/bin"
    "/usr/local/bin"
    "$HOME/.local/bin"
)

for path_item in "${important_paths[@]}"; do
    if [[ ":$PATH:" == *":$path_item:"* ]]; then
        print_test "PATH contains $path_item" "pass" ""
    else
        print_test "PATH contains $path_item" "warn" "Not in PATH"
    fi
done

# Check for NVM path if NVM is loaded
if [[ -n "$NVM_DIR" ]] && [[ -d "$NVM_DIR/versions/node" ]]; then
    # Check if any node version bin is in PATH
    if echo "$PATH" | grep -q "$NVM_DIR/versions/node"; then
        local node_version=$(echo "$PATH" | grep -o "$NVM_DIR/versions/node/[^:]*" | head -1 | xargs basename 2>/dev/null)
        print_test "NVM Node in PATH" "pass" "$node_version"
    else
        print_test "NVM Node in PATH" "warn" "Node bin directory not found in PATH"
    fi
fi

# Check for duplicate PATH entries
local path_array=("${(@s/:/)PATH}")
local unique_paths=("${(@u)path_array}")
if [[ ${#path_array[@]} -eq ${#unique_paths[@]} ]]; then
    print_test "PATH Deduplication" "pass" "No duplicate entries"
else
    local duplicate_count=$((${#path_array[@]} - ${#unique_paths[@]}))
    print_test "PATH Deduplication" "warn" "$duplicate_count duplicate entries found"
fi

# ============================================================================
# PERFORMANCE CHECKS
# ============================================================================
print_header "Performance Checks"

# Test shell startup time (approximation)
echo -e "${CYAN}  ${INFO} Measuring shell startup time (3 samples)...${RESET}"
local total_time=0
for i in {1..3}; do
    local start=$(date +%s%N)
    zsh -i -c exit >/dev/null 2>&1
    local end=$(date +%s%N)
    local elapsed=$(( (end - start) / 1000000 )) # Convert to milliseconds
    total_time=$((total_time + elapsed))
done
local avg_time=$((total_time / 3))
local startup_seconds=$(awk "BEGIN {printf \"%.2f\", $avg_time/1000}")

if [[ $avg_time -lt 500 ]]; then
    print_test "Shell Startup Time" "pass" "${startup_seconds}s (Excellent - instant)"
elif [[ $avg_time -lt 1000 ]]; then
    print_test "Shell Startup Time" "pass" "${startup_seconds}s (Good - very responsive)"
elif [[ $avg_time -lt 2000 ]]; then
    print_test "Shell Startup Time" "warn" "${startup_seconds}s (Acceptable - could be faster)"
else
    print_test "Shell Startup Time" "warn" "${startup_seconds}s (Slow - consider optimization)"
fi

# ============================================================================
# SUMMARY
# ============================================================================
echo ""
echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
echo -e "${BOLD}${MAGENTA}Test Summary${RESET}"
echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
echo ""

local total_tests=$((PASSED + FAILED + WARNINGS))
local pass_rate=0
if [[ $total_tests -gt 0 ]]; then
    pass_rate=$(( (PASSED * 100) / total_tests ))
fi

echo -e "  ${GREEN}${CHECK} Passed:   ${BOLD}${PASSED}${RESET}"
echo -e "  ${RED}${CROSS} Failed:   ${BOLD}${FAILED}${RESET}"
echo -e "  ${YELLOW}${WARN} Warnings: ${BOLD}${WARNINGS}${RESET}"
echo -e "  ${CYAN}━━━━━━━━━━━━━━━━━━━━━${RESET}"
echo -e "  ${BOLD}Total:    ${total_tests}${RESET}"
echo -e "  ${BOLD}Pass Rate: ${pass_rate}%${RESET}"
echo ""

# Show configuration source
if [[ "$USE_MANUAL_TESTS" == "false" ]]; then
    echo -e "${CYAN}  ${INFO} Package tests loaded from: ${PACKAGES_JSON}${RESET}"
else
    echo -e "${YELLOW}  ${WARN} Using manual package tests (packages.json or jq not available)${RESET}"
fi
echo ""

# Overall status
if [[ $FAILED -eq 0 ]]; then
    if [[ $WARNINGS -eq 0 ]]; then
        echo -e "${BOLD}${GREEN}╔════════════════════════════════════════╗${RESET}"
        echo -e "${BOLD}${GREEN}║  ${CHECK} ALL TESTS PASSED - EXCELLENT! ${CHECK}  ║${RESET}"
        echo -e "${BOLD}${GREEN}╚════════════════════════════════════════╝${RESET}"
        exit 0
    else
        echo -e "${BOLD}${YELLOW}╔═══════════════════════════════════════════════╗${RESET}"
        echo -e "${BOLD}${YELLOW}║  ${WARN} TESTS PASSED WITH WARNINGS           ║${RESET}"
        echo -e "${BOLD}${YELLOW}║    Review warnings for potential issues      ║${RESET}"
        echo -e "${BOLD}${YELLOW}╚═══════════════════════════════════════════════╝${RESET}"
        exit 0
    fi
else
    echo -e "${BOLD}${RED}╔═══════════════════════════════════════════════╗${RESET}"
    echo -e "${BOLD}${RED}║  ${CROSS} TESTS FAILED - ACTION REQUIRED        ║${RESET}"
    echo -e "${BOLD}${RED}║    Review failed tests above                 ║${RESET}"
    echo -e "${BOLD}${RED}╚═══════════════════════════════════════════════╝${RESET}"
    exit 1
fi
